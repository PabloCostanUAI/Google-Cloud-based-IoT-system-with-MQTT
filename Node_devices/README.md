# NodeJS Virtual Devices
I have created a stand-alone program that represents a virtual environmental station that generates, periodically, random values for:

* temperature (-50... 50 Celsius)
* humidity (0... 100%)
* wind direction (0... 360 degrees)
* wind intensity (0... 100 m/s)
* rain height (0... 50 mm / h)

Each virtual sensor will publish these random values on the MQTT Google channel. The script for the sensors are based on Node.js and it generates a JSON payload structured as follow:

        const payload = {
            deviceId: "station",
            temperature: getRndInteger(-50, 50),
            humidity: getRndInteger(0, 100),
            wind_direction: getRndInteger(0, 360),
            wind_intensity: getRndInteger(0, 100),
            rain_height: getRndInteger(0, 50),
            date: parseInt(Date.now()/1000)
        }
The date is important for the database and the dashboard that will have to show the last hour values received for every sensor.

## Publish/Subscribe process
![img](../img/connection.jpeg)

Here I manage the main Publish/Subscribe process. The first thing to do is to connect the sensor to the Google IoT broker by entering the arguments created on the cloud platform.

<img src="../img/subscribe.png" width="700" height="500" />

If the connection is successful the sensor starts to send the random values (line 100-105). The subsequent functions handle the errors (line 113), the closing connection (line 109) and the other messages subscribing by the platform (line117).

##Â Generate and Publish values

<img src="../img/publish2.png" width="800" height="500" />

The image above shows how to create and publish the values to the platform. Values are generated by getRndInteger (line 38) and then they are asynchronously published by the function publishAsync (line 43), every 5 seconds.

I used a Quality of Service qos1 (line 43) that is equivalent to the paradigm: at least once. Indeed with this choice, we could have the problem of duplicates but we have also higher reliability than qos0 (at most once) which could lose data. (Note: Google IoT Core doesn't support qos2, exactly once).

For more details on this part I based my code on the following Google Guide: [Publishing over the MQTT bridge - Guide](https://cloud.google.com/iot/docs/how-tos/mqtt-bridge#publishing_telemetry_events)